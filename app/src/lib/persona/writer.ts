import * as fs from "fs";
import * as path from "path";
import type { Persona, PersonaSet } from "../../types/persona";

export interface PersonaWriteResult {
  primaryMd: string;
  secondaryMd: string;
  personasJson: string;
}

export function generatePrimaryPersonaMd(persona: Persona): string {
  const lines: string[] = [];

  lines.push(`# Primary Persona: ${persona.name}`);
  lines.push("");
  lines.push(`> ${persona.oneLiner}`);
  lines.push("");

  // Demographics table
  lines.push("## Demographics");
  lines.push("");
  lines.push("| Attribute | Value |");
  lines.push("|-----------|-------|");
  lines.push(`| Age | ${persona.demographics.ageRange} |`);
  lines.push(`| Location | ${persona.demographics.location} |`);
  lines.push(`| Occupation | ${persona.demographics.occupation} |`);
  if (persona.demographics.income) {
    lines.push(`| Income | ${persona.demographics.income} |`);
  }
  if (persona.demographics.primaryGender) {
    lines.push(`| Gender | ${persona.demographics.primaryGender} |`);
  }
  if (persona.demographics.education) {
    lines.push(`| Education | ${persona.demographics.education} |`);
  }
  lines.push("");

  // Tech Profile
  lines.push("## Tech Profile");
  lines.push("");
  lines.push(`- **Devices:** ${persona.techProfile.devices.join(", ")}`);
  lines.push(`- **App Usage:** ${persona.techProfile.appUsageFrequency}`);
  lines.push(`- **Tech Comfort:** ${persona.techProfile.techComfort}/5`);
  lines.push(
    `- **Payment Willingness:** ${formatPaymentWillingness(persona.techProfile.paymentWillingness)}`
  );
  lines.push(
    `- **Privacy Concern:** ${formatPrivacyConcern(persona.techProfile.privacyConcern)}`
  );
  lines.push("");

  // Behavior
  lines.push("## Behavior");
  lines.push("");
  lines.push("### Usage Patterns");
  lines.push(
    `- **Peak times:** ${persona.behavior.peakUsageTimes.join(", ")}`
  );
  lines.push(`- **Session duration:** ${persona.behavior.sessionDuration}`);
  lines.push(
    `- **Primary motivation:** ${persona.behavior.primaryMotivation}`
  );
  lines.push("");

  lines.push("### Frustrations");
  for (const frustration of persona.behavior.frustrations) {
    lines.push(`- ${frustration}`);
  }
  lines.push("");

  lines.push("### Current Alternatives");
  for (const alt of persona.behavior.alternatives) {
    lines.push(`- ${alt}`);
  }
  lines.push("");

  // Goals
  lines.push("## Goals");
  lines.push("");
  for (const goal of persona.goals) {
    lines.push(`- ${goal}`);
  }
  lines.push("");

  // Pain Points
  lines.push("## Pain Points");
  lines.push("");
  for (const painPoint of persona.painPoints) {
    lines.push(`- ${painPoint}`);
  }
  lines.push("");

  // Quote
  lines.push("## Characteristic Quote");
  lines.push("");
  lines.push(`> "${persona.quote}"`);
  lines.push("");

  // Footer
  lines.push("---");
  lines.push("");
  lines.push(`*Data source: ${persona.dataSource}*`);
  lines.push(`*Generated by FORK on ${new Date().toISOString().split("T")[0]}*`);

  return lines.join("\n");
}

export function generateSecondaryPersonasMd(personas: Persona[]): string {
  const lines: string[] = [];

  lines.push("# Secondary Personas");
  lines.push("");
  lines.push(
    "> These personas represent minority user segments with different needs and behaviors."
  );
  lines.push("");

  for (let i = 0; i < personas.length; i++) {
    const persona = personas[i];

    lines.push(`## ${i + 1}. ${persona.name}`);
    lines.push("");
    lines.push(`> ${persona.oneLiner}`);
    lines.push("");

    // Compact demographics
    lines.push("### Profile");
    lines.push("");
    lines.push(
      `- **Age:** ${persona.demographics.ageRange} | **Location:** ${persona.demographics.location}`
    );
    lines.push(
      `- **Occupation:** ${persona.demographics.occupation} | **Tech Comfort:** ${persona.techProfile.techComfort}/5`
    );
    lines.push(
      `- **Devices:** ${persona.techProfile.devices.join(", ")}`
    );
    lines.push(
      `- **Usage:** ${persona.techProfile.appUsageFrequency} | **Session:** ${persona.behavior.sessionDuration}`
    );
    lines.push("");

    // Goals (condensed)
    lines.push("### Goals");
    lines.push("");
    for (const goal of persona.goals) {
      lines.push(`- ${goal}`);
    }
    lines.push("");

    // Pain Points (condensed)
    lines.push("### Pain Points");
    lines.push("");
    for (const painPoint of persona.painPoints) {
      lines.push(`- ${painPoint}`);
    }
    lines.push("");

    // Quote
    lines.push("### Quote");
    lines.push("");
    lines.push(`> "${persona.quote}"`);
    lines.push("");

    if (i < personas.length - 1) {
      lines.push("---");
      lines.push("");
    }
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push(`*Generated by FORK on ${new Date().toISOString().split("T")[0]}*`);

  return lines.join("\n");
}

export function generatePersonasJson(personaSet: PersonaSet): string {
  return JSON.stringify(personaSet, null, 2);
}

export async function writePersonaFiles(
  projectDir: string,
  personaSet: PersonaSet
): Promise<PersonaWriteResult> {
  const personasDir = path.join(projectDir, ".rork", "personas");

  // Ensure directory exists
  if (!fs.existsSync(personasDir)) {
    fs.mkdirSync(personasDir, { recursive: true });
  }

  // Generate content
  const primaryMdContent = generatePrimaryPersonaMd(personaSet.primary);
  const secondaryMdContent = generateSecondaryPersonasMd(personaSet.secondary);
  const jsonContent = generatePersonasJson(personaSet);

  // Write files
  const primaryMdPath = path.join(personasDir, "primary.md");
  const secondaryMdPath = path.join(personasDir, "secondary.md");
  const jsonPath = path.join(personasDir, "personas.json");

  fs.writeFileSync(primaryMdPath, primaryMdContent, "utf-8");
  fs.writeFileSync(secondaryMdPath, secondaryMdContent, "utf-8");
  fs.writeFileSync(jsonPath, jsonContent, "utf-8");

  return {
    primaryMd: primaryMdPath,
    secondaryMd: secondaryMdPath,
    personasJson: jsonPath,
  };
}

export async function readPersonaSet(
  projectDir: string
): Promise<PersonaSet | null> {
  const jsonPath = path.join(projectDir, ".rork", "personas", "personas.json");

  if (!fs.existsSync(jsonPath)) {
    return null;
  }

  try {
    const content = fs.readFileSync(jsonPath, "utf-8");
    return JSON.parse(content) as PersonaSet;
  } catch {
    return null;
  }
}

export function personasExist(projectDir: string): boolean {
  const jsonPath = path.join(projectDir, ".rork", "personas", "personas.json");
  return fs.existsSync(jsonPath);
}

function formatPaymentWillingness(
  willingness: "free-only" | "low" | "moderate" | "high"
): string {
  const labels: Record<typeof willingness, string> = {
    "free-only": "Free only - Won't pay for apps",
    low: "Low - Occasional small purchases",
    moderate: "Moderate - Willing to pay for value",
    high: "High - Premium user, values quality",
  };
  return labels[willingness];
}

function formatPrivacyConcern(concern: "low" | "moderate" | "high"): string {
  const labels: Record<typeof concern, string> = {
    low: "Low - Shares data freely",
    moderate: "Moderate - Selective sharing",
    high: "High - Privacy-conscious, minimal data",
  };
  return labels[concern];
}
