import type { Requirements, Feature, Conflict } from "../../types/idea";
import { describeTier } from "../budget";

export function generateRequirementsMd(req: Requirements): string {
  const lines: string[] = [];

  lines.push(`# App Requirements: ${req.name}`);
  lines.push("");
  lines.push(`> ${req.tagline}`);
  lines.push("");

  // Core Problem
  lines.push("## Core Problem");
  lines.push("");
  lines.push(req.problem);
  lines.push("");

  // Target User
  lines.push("## Target User");
  lines.push("");
  lines.push(`- **Who:** ${req.targetUser.demographic}`);
  lines.push(`- **Goal:** ${req.targetUser.goal}`);
  lines.push(`- **Context:** ${req.targetUser.context}`);
  lines.push("");

  // MVP Features
  lines.push("## MVP Features");
  lines.push("");

  const mustHave = req.features.filter((f) => f.priority === "must-have");
  const shouldHave = req.features.filter((f) => f.priority === "should-have");
  const niceToHave = req.features.filter((f) => f.priority === "nice-to-have");

  if (mustHave.length > 0) {
    lines.push("### Must Have");
    lines.push("");
    for (const feature of mustHave) {
      lines.push(...formatFeature(feature));
    }
  }

  if (shouldHave.length > 0) {
    lines.push("### Should Have");
    lines.push("");
    for (const feature of shouldHave) {
      lines.push(...formatFeature(feature));
    }
  }

  if (niceToHave.length > 0) {
    lines.push("### Nice to Have");
    lines.push("");
    for (const feature of niceToHave) {
      lines.push(...formatFeature(feature));
    }
  }

  // Platform Requirements
  lines.push("## Platform Requirements");
  lines.push("");
  lines.push(`- **iOS:** ${req.platforms.includes("ios") ? "Yes" : "No"}`);
  lines.push(`- **Android:** ${req.platforms.includes("android") ? "Yes" : "No"}`);
  lines.push(`- **Offline Support:** ${formatOfflineSupport(req.offlineSupport)}`);
  lines.push("");

  // Budget Constraints
  lines.push("## Budget Constraints");
  lines.push("");
  lines.push(`- **Tier:** ${req.tier}`);
  lines.push(`- **Details:** ${describeTier(req.tier)}`);
  lines.push("");

  // Conflicts (if any)
  if (req.conflicts.length > 0) {
    lines.push("## Conflicts");
    lines.push("");
    lines.push(
      "> The following features conflict with the selected budget tier:"
    );
    lines.push("");
    for (const conflict of req.conflicts) {
      lines.push(`- **${conflict.featureId}**: ${conflict.reason}`);
      lines.push(`  - Resolution: ${conflict.resolution}`);
    }
    lines.push("");
  }

  // Success Criteria
  lines.push("## Success Criteria");
  lines.push("");
  lines.push("- [ ] User can complete core task in under 30 seconds");
  lines.push("- [ ] App launches in under 2 seconds");
  lines.push("- [ ] All must-have features are functional");
  if (req.offlineSupport === "required") {
    lines.push("- [ ] App works fully offline");
  }
  lines.push("");

  lines.push("---");
  lines.push("");
  lines.push(`*Generated by FORK on ${new Date().toISOString().split("T")[0]}*`);

  return lines.join("\n");
}

function formatFeature(feature: Feature): string[] {
  const lines: string[] = [];
  lines.push(`**${feature.name}**`);
  lines.push(`- ${feature.description}`);

  if (feature.requires.length > 0) {
    lines.push(`- Requires: ${feature.requires.join(", ")}`);
  }

  if (feature.excludes.length > 0) {
    lines.push(`- Not included: ${feature.excludes.join(", ")}`);
  }

  lines.push("");
  return lines;
}

function formatOfflineSupport(
  support: "required" | "nice-to-have" | "not-needed"
): string {
  switch (support) {
    case "required":
      return "Required (must work fully offline)";
    case "nice-to-have":
      return "Nice to have (graceful degradation)";
    case "not-needed":
      return "Not needed (online-only is acceptable)";
  }
}

export interface FeaturesJson {
  name: string;
  tagline: string;
  problem: string;
  targetUser: {
    demographic: string;
    goal: string;
    context: string;
  };
  features: Array<{
    id: string;
    name: string;
    priority: string;
    description: string;
    requires: string[];
    excludes: string[];
  }>;
  platforms: string[];
  offlineSupport: string;
  tier: string;
  conflicts: Array<{
    featureId: string;
    requirement: string;
    reason: string;
    resolution: string;
  }>;
  generatedAt: string;
}

export function generateFeaturesJson(req: Requirements): string {
  const json: FeaturesJson = {
    name: req.name,
    tagline: req.tagline,
    problem: req.problem,
    targetUser: req.targetUser,
    features: req.features.map((f) => ({
      id: f.id,
      name: f.name,
      priority: f.priority,
      description: f.description,
      requires: f.requires,
      excludes: f.excludes,
    })),
    platforms: req.platforms,
    offlineSupport: req.offlineSupport,
    tier: req.tier,
    conflicts: req.conflicts.map((c) => ({
      featureId: c.featureId,
      requirement: c.requirement,
      reason: c.reason,
      resolution: c.resolution,
    })),
    generatedAt: new Date().toISOString(),
  };

  return JSON.stringify(json, null, 2);
}
